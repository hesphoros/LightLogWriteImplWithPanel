

## ğŸ” é¢„ç•™ä½†æœªå®ç°çš„æ¥å£æ¸…å•

### 1. **IRotationStrategyæ¥å£** - å®Œå…¨æœªå®ç°

**æœªå®ç°æ¥å£ï¼š**
```cpp
virtual RotationDecision ShouldRotate(const RotationContext& context) const = 0;
virtual std::wstring GetStrategyName() const = 0;
virtual std::wstring GetStrategyDescription() const = 0;
virtual bool ValidateConfiguration() const = 0;
```

**å®ç°å»ºè®®ï¼š**
```cpp
// å»ºè®®åˆ›å»º RotationStrategies.cpp
class SizeBasedRotationStrategy : public IRotationStrategy {
public:
    RotationDecision ShouldRotate(const RotationContext& context) const override {
        RotationDecision decision;
        if (context.currentFileSize >= context.config.maxFileSizeMB * 1024 * 1024) {
            decision.shouldRotate = true;
            decision.reason = L"File size exceeded limit";
        }
        return decision;
    }
    
    std::wstring GetStrategyName() const override { return L"SizeBased"; }
    std::wstring GetStrategyDescription() const override { return L"Rotates based on file size"; }
    bool ValidateConfiguration() const override { return true; }
};

class TimeBasedRotationStrategy : public IRotationStrategy {
    // åŸºäºæ—¶é—´é—´éš”çš„è½®è½¬ç­–ç•¥å®ç°
};
```

### 2. **ILogFilteræ¥å£** - å®Œå…¨æœªå®ç°

**æœªå®ç°æ¥å£ï¼š**
```cpp
virtual FilterOperation ApplyFilter(const LogCallbackInfo& logInfo, LogCallbackInfo* transformedInfo = nullptr) = 0;
virtual bool IsEnabled() const = 0;
virtual void SetEnabled(bool enabled) = 0;
virtual std::wstring GetFilterName() const = 0;
```

**å®ç°å»ºè®®ï¼š**
```cpp
// å»ºè®®åˆ›å»º LogFilters.cpp
class LevelFilter : public ILogFilter {
private:
    LogLevel minLevel_;
    bool enabled_;
    
public:
    FilterOperation ApplyFilter(const LogCallbackInfo& logInfo, LogCallbackInfo* transformedInfo) override {
        if (!enabled_) return FilterOperation::Allow;
        return (logInfo.level >= minLevel_) ? FilterOperation::Allow : FilterOperation::Block;
    }
    
    bool IsEnabled() const override { return enabled_; }
    void SetEnabled(bool enabled) override { enabled_ = enabled; }
    std::wstring GetFilterName() const override { return L"LevelFilter"; }
};

class KeywordFilter : public ILogFilter {
    // åŸºäºå…³é”®å­—çš„è¿‡æ»¤å™¨å®ç°
};
```

### 3. **AsyncRotationManagerç±»** - éƒ¨åˆ†é«˜çº§åŠŸèƒ½æœªå®Œæ•´å®ç°

**éœ€è¦å®Œå–„çš„æ¥å£ï¼š**
- `GetNextRotationTime()` - è®¡ç®—ä¸‹æ¬¡è½®è½¬æ—¶é—´
- `CleanupOldArchives()` - æ¸…ç†æ—§å½’æ¡£æ–‡ä»¶çš„å…·ä½“å®ç°

**å®ç°å»ºè®®ï¼š**
```cpp
bool AsyncRotationManager::GetNextRotationTime(std::chrono::system_clock::time_point& nextTime) const override {
    if (config_.strategy != LogRotationStrategy::Time && 
        config_.strategy != LogRotationStrategy::SizeAndTime) {
        return false;
    }
    
    auto now = std::chrono::system_clock::now();
    switch (config_.timeInterval) {
        case TimeRotationInterval::Hourly:
            nextTime = now + std::chrono::hours(1);
            break;
        case TimeRotationInterval::Daily:
            nextTime = now + std::chrono::hours(24);
            break;
        // ... å…¶ä»–æ—¶é—´é—´éš”
    }
    return true;
}

size_t AsyncRotationManager::CleanupOldArchives() override {
    if (config_.maxArchiveFiles == 0) return 0;
    
    namespace fs = std::filesystem;
    std::vector<fs::path> archiveFiles;
    
    // æ‰«æå½’æ¡£ç›®å½•
    for (const auto& entry : fs::directory_iterator(config_.archiveDirectory)) {
        if (entry.is_regular_file()) {
            archiveFiles.push_back(entry.path());
        }
    }
    
    // æŒ‰ä¿®æ”¹æ—¶é—´æ’åºï¼Œåˆ é™¤æœ€æ—§çš„æ–‡ä»¶
    std::sort(archiveFiles.begin(), archiveFiles.end(), 
        [](const fs::path& a, const fs::path& b) {
            return fs::last_write_time(a) < fs::last_write_time(b);
        });
    
    size_t deletedCount = 0;
    while (archiveFiles.size() > config_.maxArchiveFiles) {
        fs::remove(archiveFiles.front());
        archiveFiles.erase(archiveFiles.begin());
        deletedCount++;
    }
    
    return deletedCount;
}
```

### 4. **æ€§èƒ½åˆ†æå™¨å’Œé”™è¯¯å¤„ç†å™¨** - å®Œå…¨æœªå®ç°

**ç¼ºå¤±çš„ç»„ä»¶ï¼š**
- `PerformanceProfiler.h` - æ€§èƒ½åˆ†æ
- `RotationErrorHandler.h` - é”™è¯¯å¤„ç†
- `TransactionalRotation.h` - äº‹åŠ¡æ€§è½®è½¬

**å®ç°å»ºè®®ï¼š**
```cpp
// PerformanceProfiler.h
class PerformanceProfiler {
public:
    void StartProfiling(const std::string& operation);
    void EndProfiling(const std::string& operation);
    std::map<std::string, ProfileStats> GetStats() const;
};

// RotationErrorHandler.h  
class RotationErrorHandler {
public:
    bool HandleError(const RotationError& error);
    void SetRetryPolicy(const RetryPolicy& policy);
    std::vector<RotationError> GetErrorHistory() const;
};
```

### 5. **çŠ¶æ€æœºå’Œé¢„æ£€æŸ¥å™¨** - æ¥å£å­˜åœ¨ä½†å®ç°ç®€åŒ–

**éœ€è¦å®Œæ•´å®ç°çš„ç»„ä»¶ï¼š**
- `RotationStateMachine.h` - çŠ¶æ€æœºç®¡ç†
- `RotationPreChecker.h` - è½®è½¬å‰æ£€æŸ¥ 

å·²å®Œæˆ(3/4) *åˆ†æå…·ä½“çš„æœªå®ç°æ¥å£*

## ğŸ“‹ å®ç°ä¼˜å…ˆçº§å»ºè®®

### ğŸ”´ **é«˜ä¼˜å…ˆçº§ï¼ˆæ ¸å¿ƒåŠŸèƒ½ï¼‰**
1. **IRotationStrategyæ¥å£å®ç°** - è½®è½¬ç­–ç•¥æ˜¯æ ¸å¿ƒåŠŸèƒ½
2. **AsyncRotationManageré«˜çº§åŠŸèƒ½å®Œå–„** - æå‡è½®è½¬å¯é æ€§
3. **ILogFilteræ¥å£å®ç°** - æ—¥å¿—è¿‡æ»¤æ˜¯å¸¸ç”¨åŠŸèƒ½

### ğŸŸ¡ **ä¸­ä¼˜å…ˆçº§ï¼ˆå¢å¼ºåŠŸèƒ½ï¼‰**
4. **PerformanceProfiler** - æ€§èƒ½ç›‘æ§
5. **RotationErrorHandler** - é”™è¯¯å¤„ç†
6. **TransactionalRotation** - äº‹åŠ¡æ€§æ“ä½œ

### ğŸŸ¢ **ä½ä¼˜å…ˆçº§ï¼ˆè¾…åŠ©åŠŸèƒ½ï¼‰**
7. **RotationStateMachine** - çŠ¶æ€ç®¡ç†
8. **RotationPreChecker** - é¢„æ£€æŸ¥æœºåˆ¶

## ğŸ› ï¸ å¼€å‘å»ºè®®

1. **åˆ›å»ºæ–°æ–‡ä»¶**ï¼š
   - `src/log/RotationStrategies.cpp` - è½®è½¬ç­–ç•¥å®ç°
   - `src/log/LogFilters.cpp` - æ—¥å¿—è¿‡æ»¤å™¨å®ç°
   - `src/log/PerformanceProfiler.cpp` - æ€§èƒ½åˆ†æå™¨

2. **å®Œå–„ç°æœ‰å®ç°**ï¼š
   - å¢å¼º `EnhancedRotationManager` çš„é«˜çº§åŠŸèƒ½
   - å®Œå–„ `LogCompressor` çš„ç»Ÿè®¡å›è°ƒæœºåˆ¶

3. **æµ‹è¯•æ–‡ä»¶åˆ›å»º**ï¼š
   - ä¸ºæ¯ä¸ªæ–°æ¥å£åˆ›å»ºå¯¹åº”çš„å•å…ƒæµ‹è¯•
   - é›†æˆæµ‹è¯•éªŒè¯æ¥å£é—´çš„åä½œ

è¿™äº›æœªå®ç°çš„æ¥å£ä¸ºåº“æä¾›äº†æ‰©å±•ç©ºé—´ï¼Œå¯ä»¥æ ¹æ®å®é™…éœ€æ±‚é€æ­¥å®ç°å®Œå–„ã€‚

å·²è¿›è¡Œæ›´æ”¹ã€‚